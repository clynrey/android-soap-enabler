#**
    Android SOAP Enabler is free software: you can redistribute it and/or modify
    it under the terms of the Lesser GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, 
    or any later version.

    Android SOAP Enabler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the Lesser GNU General Public License
    along with Android SOAP Enabler.  If not, see <http://www.gnu.org/licenses/>.

    Â©2011, Android SOAP Enabler Development Team
*#/**
 * GENERATED CODE - DO NOT EDIT THIS FILE
 * generated from service-implementation.java.vm
 */
package ${type.namespace.toJavaPackage()};

import fr.norsys.asoape.ws.WSCallBack;
import fr.norsys.asoape.log.Logger;
import fr.norsys.asoape.ws.transport.HttpTransport;
import fr.norsys.asoape.xml.binding.BindingContext;
import fr.norsys.asoape.xml.binding.MarshallingException;
import fr.norsys.asoape.xml.soap.SoapEnvelope;

/**
 * $type service implementation.
 */
public class ${type.toJavaType()}Impl
	implements ${type.toJavaType()}
{
	private static final String DEFAULT_SERVICE_URL = "${type.serviceUrl}";

	private java.net.URL serviceUrl;

	private BindingContext bindingContext;

	private HttpTransport transport;

	private Logger logger;

	public ${type.toJavaType()}Impl()
		throws java.net.MalformedURLException
	{
		this( new java.net.URL( DEFAULT_SERVICE_URL ), null );
	}

	public ${type.toJavaType()}Impl( java.net.URL serviceUrl, Logger logger )
	{
		this( serviceUrl, null, null, logger );
	}

	public ${type.toJavaType()}Impl( java.net.URL serviceUrl, String username, String password, Logger logger )
	{
		this.serviceUrl = serviceUrl;
		this.bindingContext = new BindingContext();
		bindingContext.add( SoapEnvelope.class);
		this.transport = new HttpTransport( bindingContext, username, password, logger);
		this.logger = logger;
	}

	public ${type.toJavaType()}Impl( java.net.URL serviceUrl, String username, String password, Integer connectionTimeout, Integer socketTimeout, Logger logger )
	{
		this.serviceUrl = serviceUrl;
		this.bindingContext = new BindingContext();
		bindingContext.add( SoapEnvelope.class);
		this.transport = new HttpTransport( bindingContext, username, password, connectionTimeout, socketTimeout, logger );
		this.logger = logger;
	}


	@SuppressWarnings( "unchecked" )
#foreach( $operation in ${type.operations} )
#if ( ${operation.output} )
#set( $output = ${operation.output.parts.iterator().next()} )
#if ( ${operation.output.getPart("parameters")} )
	public ${operation.output.getPart("parameters").element.type.toFullQualifiedJavaType()}
#else
	public ${output.type.toFullQualifiedJavaType()}
#end
		${operation.name} (
#if ( ${operation.input.getPart("parameters")} )
		${operation.input.getPart("parameters").element.type.toFullQualifiedJavaType()} ${operation.input.getPart("parameters").element.name}
	)
#else
#foreach( $input in ${operation.input.parts} )
		${input.type.toFullQualifiedJavaType()} ${input.name}#if( $velocityCount < ${operation.input.parts.size()} - 1 ),
#end
#end
	)
#end
#if( ${operation.faults.size()} > 0 )
#then
		throws
#foreach( $fault in ${operation.faults} )
			${fault.parts.iterator().next().type.toFullQualifiedJavaType()},
#end
			java.io.IOException
#else
		throws java.io.IOException
#end
	{
#if ( ${operation.input.getPart("parameters")} )
		bindingContext.add( ${operation.input.getPart("parameters").element.type.toJavaType()}.class );
#else
		bindingContext.add( ${operation.input.toJavaType()}.class );
#end
#if ( ${operation.output.getPart("parameters")} )
		bindingContext.add( ${operation.output.getPart("parameters").element.type.toJavaType()}.class );
#else
		bindingContext.add( ${operation.output.toJavaType()}.class );
#end
        SoapEnvelope out = new SoapEnvelope();
#if ( ${operation.style} == "rpc" )
        //  RPC style operation
        ${operation.input.toJavaType()} request = new ${operation.input.toJavaType()}();
#foreach( $input in ${operation.input.parts} )
        request.set${string.capitalize(${input.name})}( ${input.name} );
#end
        out.getBody().add( request );
#elseif ( ${operation.style} == "document" )
        //  Document style operation
#if ( ${operation.input.getPart("parameters")} )
        out.getBody().add( ${operation.input.getPart("parameters").element.name} );
#else
#foreach( $input in ${operation.input.parts} )
        out.getBody().add( ${input.name} );
#end
#end
#end
		try
		{
        	SoapEnvelope in = transport.send( serviceUrl, out );
#if ( ${operation.style} == "rpc" )
        	${operation.output.toJavaType()} response = (${operation.output.toJavaType()}) in.getBody().get( 0 );
#set ( $partName = ${operation.output.parts.get(0).name} )
#if ( ${string.isJavaKeyword(${partName})} )
#set ( $partName = ${partName.toUpperCase()} )
#end
        	return response.get${string.capitalize(${partName})}();
#elseif ( ${operation.style} == "document" )
#if ( ${operation.output.getPart("parameters")} )
        	${operation.output.getPart("parameters").element.type.toFullQualifiedJavaType()} response = (${operation.output.getPart("parameters").element.type.toFullQualifiedJavaType()}) in.getBody().get( 0 );
#else
        	${operation.output.toJavaType()} response = (${operation.output.toJavaType()}) in.getBody().get( 0 );
#end
        	return response;
#end
        }
        catch ( MarshallingException cause )
        {
        	throw new java.io.IOException( cause.getMessage() );
        }
	}

	public void ${operation.name}(
#foreach( $input in ${operation.input.parts} )
		final ${input.type.toFullQualifiedJavaType()} ${input.name},
#end
		final WSCallBack<${output.type.toFullQualifiedJavaType()}> callBack )
	{
        new Thread()
        {
            @Override
            public void run()
            {
                try
                {
                    ${output.type.toFullQualifiedJavaType()} result = ${operation.name}(
#foreach( $input in ${operation.input.parts} )
						${input.name}#if( $velocityCount < ${operation.input.parts.size()} - 1 ),
#end
#end
					);
                    try {
                    	callBack.onSuccess( result );
                    } catch (Throwable throwable ) {
                    	if ( logger != null && logger.isErrorEnabled() )
                    		logger.error("error during callback.onSuccess()", throwable );
                	} 
                }
                catch ( Throwable throwable )
                {
                    callBack.onFailure( throwable );
                }
            }
        }.start();
	}
#else
	/**
	 * Operation ${operation.name}
	 *
	 * @param ${input.name} Request.
	 * @throws java.io.IOException Error occurs during remote call.
	 */
	public void ${operation.name}( ${input.type.toFullQualifiedJavaType()} ${input.name} )
		throws java.io.IOException
	{
		bindingContext.add( ${input.type.toFullQualifiedJavaType()}.class);
        SoapEnvelope out = new SoapEnvelope();
        out.getBody().add( ${input.name} );
		try
		{
        	transport.sendAsync( serviceUrl, out );
        }
        catch ( MarshallingException cause )
        {
        	throw new java.io.IOException( cause.getMessage() );
        }
	}
#end
#end
}
